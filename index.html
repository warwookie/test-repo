// Finish the truncated line
const hudRoot2 = document.querySelector('.hud2');

// Debounced live counter updates when HUD DOM changes
(function(){
  if(!window.MutationObserver) return;
  const debounced = (()=>{let f=0; return ()=>{ cancelAnimationFrame(f); f=requestAnimationFrame(updateIconCounters); };})();
  const obs = new MutationObserver(debounced);
  if(hudRoot1) obs.observe(hudRoot1,{childList:true,subtree:true,attributes:true,attributeFilter:['class']});
  if(hudRoot2) obs.observe(hudRoot2,{childList:true,subtree:true,attributes:true,attributeFilter:['class']});
})();

/* ----------------------------
   Icon Amounts — UI + Logic
   (Works even if the HTML block
    was truncated — we inject it)
-----------------------------*/

// Create the “Icon Amounts” UI if missing
function ensureIconAmountsUI(){
  const body = document.getElementById('tBody');
  if(!body) return;
  const need =
    !document.getElementById('v_count_hearts') ||
    !document.getElementById('v_count_shoes') ||
    !document.getElementById('v_count_powerups') ||
    !document.getElementById('v_count_fire');

  if(!need) return;

  const wrap = document.createElement('div');
  wrap.className = 'tg';
  wrap.innerHTML = `
    <h4>Icon Amounts</h4>
    <div class="tr" style="grid-template-columns:1fr 120px 60px auto">
      <label>Hearts</label>
      <input id="v_count_hearts" type="number" min="0" max="10" step="1" inputmode="numeric">
      <div class="tv" id="o_count_hearts_set"></div>
      <div></div>
    </div>
    <div class="tr" style="grid-template-columns:1fr 120px 60px auto">
      <label>Sneakers</label>
      <input id="v_count_shoes" type="number" min="0" max="10" step="1" inputmode="numeric">
      <div class="tv" id="o_count_shoes_set"></div>
      <div></div>
    </div>
    <div class="tr" style="grid-template-columns:1fr 120px 60px auto">
      <label>Power-ups</label>
      <input id="v_count_powerups" type="number" min="0" max="12" step="1" inputmode="numeric">
      <div class="tv" id="o_count_powerups_set"></div>
      <div></div>
    </div>
    <div class="tr" style="grid-template-columns:1fr 120px 60px auto">
      <label>Fire</label>
      <input id="v_count_fire" type="number" min="0" max="12" step="1" inputmode="numeric">
      <div class="tv" id="o_count_fire_set"></div>
      <div></div>
    </div>

    <div class="tr" style="grid-template-columns:1fr auto"><label>Hearts (live)</label><div class="tv" id="o_count_hearts">0</div></div>
    <div class="tr" style="grid-template-columns:1fr auto"><label>Sneakers (live)</label><div class="tv" id="o_count_shoes">0</div></div>
    <div class="tr" style="grid-template-columns:1fr auto"><label>Power-ups (live)</label><div class="tv" id="o_count_powerups">0</div></div>
    <div class="tr" style="grid-template-columns:1fr auto"><label>Fire (live)</label><div class="tv" id="o_count_fire">0</div></div>
  `;
  body.appendChild(wrap);
}

// Renderers
function renderHearts(n){
  const c=document.querySelector('.slot-heart .line'); if(!c) return;
  let s=''; for(let i=0;i<n;i++) s+='<i class="ph-fill ph-heart" aria-hidden="true"></i>';
  c.innerHTML=s;
}
function renderShoes(n){
  const c=document.querySelector('.slot-shoes .line'); if(!c) return;
  let s=''; const red=Math.min(2,n);
  for(let i=0;i<red;i++) s+='<span style="color:#ff3a2f"><i class="ph-bold ph-sneaker" aria-hidden="true"></i></span>';
  for(let i=red;i<n;i++) s+='<i class="ph-fill ph-sneaker" aria-hidden="true"></i>';
  c.innerHTML=s;
}
function renderPowerups(n){
  const c=document.querySelector('.slot-dots .line'); if(!c) return;
  const types=['timer','shield','magnet','crosshair-simple'];
  let s=''; for(let i=0;i<n;i++){ const t=types[i%types.length];
    s+='<span class="power power--idle" data-power="'+t+'"><i class="ph-bold ph-'+t+'" aria-hidden="true"></i></span>';
  }
  c.innerHTML=s;
}
function renderFire(n){
  const c=document.querySelector('.slot-flames .line'); if(!c) return;
  let s=''; for(let i=0;i<n;i++) s+='<i class="ph-fill ph-fire" aria-hidden="true"></i>';
  c.innerHTML=s;
}

function renderAllIconAmounts(){
  const H=parseInt(state['count-hearts']??'3',10);
  const S=parseInt(state['count-shoes']??'5',10);
  const P=parseInt(state['count-powerups']??'4',10);
  const F=parseInt(state['count-fire']??'5',10);
  renderHearts(H); renderShoes(S); renderPowerups(P); renderFire(F);
  updateIconCounters();
}

// Bind a number input to state + re-render
function bindCount(id,key,outId){
  const el=qs(id), out=qs(outId); if(!el) return;
  const set=(v)=>{
    const min=+el.min||0, max=+el.max||99;
    const n=Math.max(min,Math.min(max,parseInt(v||'0',10)));
    state[key]=String(n); if(out) out.textContent=String(n);
    save(); renderAllIconAmounts();
  };
  if(state[key]==null){
    if(key==='count-hearts')   state[key]=String(document.querySelectorAll('.slot-heart .ph-heart:not(.is-off)').length||3);
    if(key==='count-shoes')    state[key]=String(document.querySelectorAll('.slot-shoes .ph-sneaker').length||5);
    if(key==='count-powerups') state[key]=String(document.querySelectorAll('.slot-dots .power').length||4);
    if(key==='count-fire')     state[key]=String(document.querySelectorAll('.slot-flames .ph-fire:not(.is-off)').length||5);
  }
  el.value=String(state[key]); if(out) out.textContent=String(state[key]);
  el.addEventListener('input',e=>set(e.target.value));
}

// Ensure UI exists, then wire it
ensureIconAmountsUI();
bindCount('v_count_hearts','count-hearts','o_count_hearts_set');
bindCount('v_count_shoes','count-shoes','o_count_shoes_set');
bindCount('v_count_powerups','count-powerups','o_count_powerups_set');
bindCount('v_count_fire','count-fire','o_count_fire_set');

// Initial render for icon amounts + live counters
renderAllIconAmounts();

// Auto-open tuner once after restore
try{
  if(!localStorage.getItem(storageKey+':tuner_seen')){
    document.getElementById('tunerFloat').classList.add('open');
    localStorage.setItem(storageKey+':tuner_seen','1');
  }
}catch(_){}

/* END tuner IIFE */
})();
</script>
<script>
/* =========================
   Controls: JOYPAD + BUTTONS
   - Lightweight, no bloat
   - Bomb effects only in 1-button mode
========================= */

/* Prevent scrolling on touch over controls */
document.addEventListener('touchmove', (e)=>{
  if(e.target.closest('#left-area, #right-area')) e.preventDefault();
},{passive:false});

/* ---------- JOYPAD (right) ---------- */
(() => {
  const cvs=document.getElementById('jpad_canvas'); if(!cvs) return;
  const ctx=cvs.getContext('2d');
  const out=document.getElementById('jpad_status');
  const area=document.getElementById('right-area');
  let W=0,H=0,CX=0,CY=0,R=0, nx=0, ny=0, tx=0, ty=0;
  const DEAD=0.15, SMOOTH=0.22;

  function layout(w,h){
    cvs.width=w; cvs.height=h; W=w; H=h; CX=W/2; CY=H/2; R=Math.min(W,H)*0.38;
  }
  new ResizeObserver(entries=>{
    const r=entries[0].contentRect;
    const pad=16; // matches .control-ui .pad inset
    layout(Math.max(1,Math.floor(r.width- pad*2)), Math.max(1,Math.floor(r.height- pad*2)));
  }).observe(area);

  function toNorm(x,y){
    const dx=x-CX, dy=y-CY; let d=Math.hypot(dx,dy); const a=Math.atan2(dy,dx);
    let r=Math.min(1,d/R); if(r<DEAD) r=0; else r=(r-DEAD)/(1-DEAD);
    return {x:Math.cos(a)*r, y:Math.sin(a)*r};
  }
  function pos(e){const b=cvs.getBoundingClientRect();return{x:e.clientX-b.left,y:e.clientY-b.top};}
  const active=new Set();
  function set(e,val){ try{cvs.setPointerCapture(e.pointerId);}catch(_){} active.add(e.pointerId); const p=pos(e); const v=toNorm(p.x,p.y); tx=v.x; ty=v.y; }
  function mov(e){ if(!active.has(e.pointerId)) return; const p=pos(e); const v=toNorm(p.x,p.y); tx=v.x; ty=v.y; }
  function end(e){ active.delete(e.pointerId); if(!active.size){ tx=0; ty=0; } }

  cvs.addEventListener('pointerdown',set);
  cvs.addEventListener('pointermove',mov);
  ['pointerup','pointercancel','pointerleave'].forEach(t=>cvs.addEventListener(t,end));

  function draw(){
    nx += (tx-nx)*SMOOTH; ny += (ty-ny)*SMOOTH;
    ctx.clearRect(0,0,W,H);
    // base
    ctx.fillStyle='#070404'; ctx.fillRect(0,0,W,H);
    // ring
    ctx.strokeStyle='#2a0000'; ctx.lineWidth=8; ctx.beginPath(); ctx.arc(CX,CY,R,0,Math.PI*2); ctx.stroke();
    // knob
    const kx=CX+nx*R, ky=CY+ny*R;
    const g=ctx.createRadialGradient(kx,ky,4,kx,ky,28);
    g.addColorStop(0,'#ff2a2a'); g.addColorStop(1,'#210000');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(kx,ky,22,0,Math.PI*2); ctx.fill();
    if(out){ const m=Math.min(1,Math.hypot(nx,ny)); const a=Math.atan2(ny,nx); out.value=`x ${nx.toFixed(2)}, y ${ny.toFixed(2)}, |v| ${m.toFixed(2)}, θ ${a.toFixed(2)}`; }
    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
})();

/* ---------- BUTTONS (left) ---------- */
(() => {
  const DPR=Math.max(1, Math.min(2, Math.round(devicePixelRatio||1)));
  const cvs=document.getElementById('btn2_panel'); if(!cvs) return;
  const ctx=cvs.getContext('2d');
  const proxyBlast=document.getElementById('btn2_proxy_blast');
  const proxyBomb =document.getElementById('btn2_proxy_bomb');
  const tmpBtn=document.getElementById('btn2_temp');

  // Canvas size is fixed in HTML (560). Respect DPR for crispness.
  const W=560, H=560; cvs.width=W*DPR; cvs.height=H*DPR; cvs.style.width=W+'px'; cvs.style.height=H+'px'; ctx.scale(DPR,DPR);

  // Simple geometry for two faces
  const pad=56, gap=42, faceH=Math.round((H - pad*2 - gap)/2);
  const BLAST={x:pad, y:pad, w:W-pad*2, h:faceH, r:24};
  const BOMB2={x:pad, y:pad+faceH+gap, w:W-pad*2, h:faceH, r:24};
  // Single mode face (centered)
  const BOMB1={x:pad, y:Math.round((H-faceH)/2), w:W-pad*2, h:faceH, r:24};

  // Mode state
  const state={ mode:'single', transitioning:false }; // 'single' or 'two'

  function rr(p){ const path=new Path2D(); const {x,y,w,h,r}=p;
    path.moveTo(x+r,y); path.lineTo(x+w-r,y); path.arcTo(x+w,y,x+w,y+r,r);
    path.lineTo(x+w,y+h-r); path.arcTo(x+w,y+h,x+w-r,y+h,r);
    path.lineTo(x+r,y+h); path.arcTo(x,y+h,x,y+h-r,r);
    path.lineTo(x,y+r); path.arcTo(x,y,x+r,y,r); path.closePath(); return path;
  }
  const P_BLAST=rr(BLAST), P_BOMB2=rr(BOMB2), P_BOMB1=rr(BOMB1);

  function face(p,label){
    // bezel
    ctx.fillStyle='#120e0e'; ctx.strokeStyle='#2a1511'; ctx.lineWidth=2;
    ctx.fill(rr(p)); ctx.stroke(rr(p));
    // inner
    ctx.fillStyle='#1a0e0e'; ctx.fill(rr({x:p.x+8,y:p.y+8,w:p.w-16,h:p.h-16,r:p.r-8}));
    // label (pixel font)
    ctx.save(); ctx.fillStyle='#ff3a2a'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.font="28px 'Press Start 2P'";
    ctx.fillText(label, p.x+p.w/2, p.y+p.h/2);
    ctx.restore();
  }

  function draw(){
    ctx.clearRect(0,0,W,H);
    if(state.mode==='single'){
      face(BOMB1,'BOMB X');
    }else{
      face(BLAST,'BLAST');
      face(BOMB2,'BOMB X');
    }
    // soft glow
    ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.globalAlpha=0.1;
    ctx.fillStyle='#ff3a2a'; ctx.fill(rr(state.mode==='single'?BOMB1:BOMB2));
    ctx.restore();
  }

  // Bomb effects (ONLY in single mode): a quick implosion pulse
  let implodingStart=0;
  function startImplode(){ if(state.mode!=='single') return; implodingStart=performance.now(); requestAnimationFrame(implodeFrame); }
  function implodeFrame(ts){
    if(!implodingStart) return;
    const t=(ts-implodingStart)/800; // 0..1
    draw();
    const p=BOMB1; // single-face
    const cx=p.x+p.w/2, cy=p.y+p.h/2, maxR=Math.min(p.w,p.h)*0.45;
    const r=maxR*(1-t);
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle='rgba(255,42,42,0.9)';
    ctx.lineWidth=6;
    ctx.beginPath(); ctx.arc(cx,cy,Math.max(4,r),0,Math.PI*2); ctx.stroke();
    ctx.restore();
    if(t<1) requestAnimationFrame(implodeFrame); else implodingStart=0;
  }

  // Click handling (use DPR-aware hit test)
  function hitPath(pth, clientX, clientY){
    const r=cvs.getBoundingClientRect();
    const x=(clientX-r.left)*DPR, y=(clientY-r.top)*DPR;
    return ctx.isPointInPath(pth,x,y);
  }
  cvs.addEventListener('click',(e)=>{
    if(state.mode==='single'){
      if(hitPath(P_BOMB1,e.clientX,e.clientY)){ startImplode(); } // effects allowed
    }else{
      // two-button mode: NO bomb effects
      // we still allow blast visual feedback (no field sim)
      if(hitPath(P_BLAST,e.clientX,e.clientY)){ /* optional: add tiny flash */ }
      if(hitPath(P_BOMB2,e.clientX,e.clientY)){ /* intentionally no effect */ }
    }
  });

  // Keyboard proxies map to centers
  function synthClickAtRect(p){
    const r=cvs.getBoundingClientRect();
    const cx=r.left + (p.x+p.w/2)/W * r.width;
    const cy=r.top  + (p.y+p.h/2)/H * r.height;
    const evt=new MouseEvent('click',{bubbles:true,cancelable:true,clientX:cx,clientY:cy});
    cvs.dispatchEvent(evt);
  }
  if(proxyBlast) proxyBlast.addEventListener('click',()=>{ if(state.mode==='two') synthClickAtRect(BLAST); });
  if(proxyBomb)  proxyBomb .addEventListener('click',()=>{ synthClickAtRect(state.mode==='single'?BOMB1:BOMB2); });

  // Mode transition (temp button)
  if(tmpBtn){
    tmpBtn.addEventListener('click',()=>{
      if(state.transitioning) return;
      state.transitioning=true;
      // quick redraw swap
      state.mode = (state.mode==='single'?'two':'single');
      draw();
      state.transitioning=false;
      // Update proxy layout sizes to match semantics (simple)
      if(state.mode==='single'){
        if(proxyBlast){ proxyBlast.style.display='none'; }
        if(proxyBomb){ proxyBomb.style.top='4%'; proxyBomb.style.bottom='auto'; proxyBomb.style.height='92%'; }
      }else{
        if(proxyBlast){ proxyBlast.style.display='block'; proxyBlast.style.top='6%'; proxyBlast.style.height='44%'; }
        if(proxyBomb){ proxyBomb.style.display='block'; proxyBomb.style.bottom='6%'; proxyBomb.style.top='auto'; proxyBomb.style.height='44%'; }
      }
    });
  }

  // Initial proxy layout + first paint
  if(proxyBlast){ proxyBlast.style.display='none'; }
  if(proxyBomb){  proxyBomb.style.top='4%'; proxyBomb.style.height='92%'; }
  draw();
})();
</script>
</body>
</html>
