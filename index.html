<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>DMD: Buttons (left) + Joystick/Radar (right)</title>
<style>
  :root { color-scheme: dark; }
  html, body { height: 100%; margin: 0; }
  body {
    background: #070708;
    font: 14px ui-monospace, Consolas, Menlo, monospace;
    display: grid;
    place-items: center;
    padding: 1rem;
    box-sizing: border-box;
  }
  .wrap {
    width: 100%;
    max-width: 1100px;
    display: grid;
    grid-template-columns: 1fr 1fr; /* left: buttons, right: joystick */
    border: 1px solid #1a0000;
    border-radius: 12px;
    box-shadow: inset 0 0 0 2px #000, 0 20px 50px #000c;
    overflow: hidden;
    aspect-ratio: 2 / 1; /* requested */
    background: #080203;
  }
  .pane { position: relative; }
  .pane-left, .pane-right { background: #080203; }
  .pane-left iframe { position:absolute; inset:0; width:100%; height:100%; border:0; }
  .pane-right canvas { width: 100%; height: 100%; display: block; background: #080203; }
  .note { position:absolute; inset:auto auto 8px 8px; color:#a66; font-size:12px; opacity:0.7; }
</style>
</head>
<body>
  <div class="wrap">
    <!-- LEFT: Buttons UI loaded as-is via setButtonsHTML(html). No edits. -->
    <div class="pane pane-left">
      <iframe id="buttons-frame" title="Buttons Panel" src="Buttons 100.html"></iframe>
    </div>

    <!-- RIGHT: Existing joystick/radar canvas (unchanged behavior) -->
    <div class="pane pane-right">
      <canvas id="control-panel"></canvas>
    </div>
  </div>

<script>
// ==== Left pane loader =======================================================
// Public API: call setButtonsHTML(htmlString) to inject your Buttons 100.html.
// No string templating tricks. Avoids the previous syntax error from nested
// template literals.
(function(){
  const frame = document.getElementById('buttons-frame');
  const note  = document.getElementById('left-note');

  function minimalPlaceholder(){
    // Very small, self-contained placeholder so the left pane renders safely.
    return (
      '<!doctype html><html><head><meta charset="utf-8">' +
      '<meta name="viewport" content="width=device-width,initial-scale=1">' +
      '<style>html,body{margin:0;height:100%;background:#0b0b0b}' +
      'canvas{display:block;width:100%;height:100%;image-rendering:pixelated}</style>' +
      '</head><body><canvas id="c"></canvas>' +
      '<script>' +
      'const c=document.getElementById("c"),x=c.getContext("2d");function r(){const w=c.width=innerWidth*devicePixelRatio,h=c.height=innerHeight*devicePixelRatio;x.scale(devicePixelRatio,devicePixelRatio);x.clearRect(0,0,innerWidth,innerHeight);const p=6;for(let y=0;y<innerHeight;y+=p){for(let i=0;i<innerWidth;i+=p){x.fillStyle="#1A0E0E";x.beginPath();x.arc(i,y,1.2,0,7);x.fill();}}}addEventListener("resize",r);r();' +
      '<\/script></body></html>'
    );
  }

  // Install API on window so caller can inject their exact HTML content.
  window.setButtonsHTML = function(html){
    if (typeof html !== 'string' || !html.length) {
      console.error('setButtonsHTML(html): expected a non-empty HTML string');
      return;
    }
    frame.srcdoc = html; // Browser handles the rest.
    if (note) note.remove();
  };

  // Default placeholder so the page is valid even before user injection.
  if (!frame.getAttribute('src')) frame.srcdoc = minimalPlaceholder();
})();
</script>

<script>
// ==== Right pane: Joystick + Radar (same behavior) ===========================
(function(){
  const DEADZONE = 0.15; const RESPONSE = 1.20; const SMOOTH = 0.22; const AUTO_RETURN = true;
  let PITCH = 10, DOT_R = 2.6; const LEVELS = [0,0.35,0.65,1];
  const RED='#ff2a2a', MID='#ff2a2acc', DIM='#ff2a2a66', OFF='#210000';
  const DECAY = 0.90; let buf;
  const KNOB_CORE=0.10, KNOB_GLOWR=0.30, STEM_GAIN=0.80;
  const cvs = document.getElementById('control-panel'); const ctx = cvs.getContext('2d');
  window.joypad = { x:0,y:0,mag:0,angle:0 };
  let W,H,COLS,ROWS,OX,OY; let joyCX,joyCY,joyR; let layoutReady=false;
  let outX=0,outY=0, joyTX=0,joyTY=0; const activePointers=new Map();

  function updateLayout(newWidth,newHeight){
    if(newWidth<1||newHeight<1) return;
    cvs.width=newWidth; cvs.height=newHeight; W=newWidth; H=newHeight;
    const targetRows=24; PITCH=H/targetRows; DOT_R=PITCH*0.21;
    COLS=Math.floor(W/PITCH); ROWS=Math.floor(H/PITCH);
    if(COLS<1||ROWS<1) return;
    OX=(W - COLS*PITCH)/2 + PITCH/2; OY=(H - ROWS*PITCH)/2 + PITCH/2;
    joyCX=W*0.75; joyCY=H*0.5; joyR=(H*0.5) - (PITCH*3);
    buf=new Float32Array(COLS*ROWS); layoutReady=true;
  }

  function getPointerLocation(e){ const r=cvs.getBoundingClientRect(); return {x:e.clientX-r.left, y:e.clientY-r.top}; }
  function isJoy(x){ return x>0; } // pane owns full canvas
  function joyPointerToNorm(x,y){
    const dx=x-joyCX, dy=y-joyCY; const dist=Math.hypot(dx,dy); const ang=Math.atan2(dy,dx);
    let rn=Math.min(dist/joyR,1); if(rn<DEADZONE) rn=0; else rn=(rn-DEADZONE)/(1-DEADZONE); rn=Math.pow(rn,RESPONSE);
    return { nx:Math.cos(ang)*rn, ny:Math.sin(ang)*rn };
  }

  cvs.addEventListener('pointerdown', e=>{ e.preventDefault(); const {x,y}=getPointerLocation(e); if(!isJoy(x)) return; try{ cvs.setPointerCapture(e.pointerId);}catch(_){} activePointers.set(e.pointerId,'joy'); const v=joyPointerToNorm(x,y); joyTX=v.nx; joyTY=v.ny; });
  cvs.addEventListener('pointermove', e=>{ e.preventDefault(); if(activePointers.get(e.pointerId)!=='joy') return; const {x,y}=getPointerLocation(e); const v=joyPointerToNorm(x,y); joyTX=v.nx; joyTY=v.ny; });
  function endPointer(e){ const t=activePointers.get(e.pointerId); activePointers.delete(e.pointerId); if(t==='joy'){ let active=false; for(const v of activePointers.values()) if(v==='joy') active=true; if(!active && AUTO_RETURN){ joyTX=0; joyTY=0; } } }
  cvs.addEventListener('pointerup', endPointer); cvs.addEventListener('pointercancel', endPointer); cvs.addEventListener('pointerleave', endPointer);

  function loop(){ outX += (joyTX-outX)*SMOOTH; outY += (joyTY-outY)*SMOOTH; drawDMD(outX,outY); window.joypad.x=outX; window.joypad.y=outY; window.joypad.mag=Math.min(Math.hypot(outX,outY),1); window.joypad.angle=Math.atan2(outY,outX); requestAnimationFrame(loop); }

  function drawDMD(nx,ny){
    if(!layoutReady){ ctx.clearRect(0,0,W,H); return; }
    ctx.clearRect(0,0,W,H);
    const now=performance.now()*0.001;
    const px=joyCX+nx*joyR, py=joyCY+ny*joyR, mag=Math.hypot(nx,ny);
    const knobCoreR=joyR*KNOB_CORE, knobGlowR=joyR*KNOB_GLOWR;

    for(let j=0;j<ROWS;j++){
      for(let i=0;i<COLS;i++){
        const x=OX+i*PITCH, y=OY+j*PITCH; const idx=j*COLS+i;
        buf[idx]=(buf[idx]||0)*DECAY;

        // warp around knob
        const jdx_un=x-joyCX, jdy_un=y-joyCY; let jdx=jdx_un, jdy=jdy_un;
        if(mag>0.01){
          const suck=Math.min(0.8, mag*1.2);
          const jdx_wc=x-px, jdy_wc=y-py; const divisor=(1 - suck);
          if(divisor>0.001){ const vx=jdx_wc/divisor + px; const vy=jdy_wc/divisor + py; jdx=vx-joyCX; jdy=vy-joyCY; }
        }

        const jd=Math.hypot(jdx,jdy); const jang=Math.atan2(jdy,jdx);
        const ringThick=PITCH*0.75, dzRingThick=PITCH*0.5;
        const t=(now*1.6)%(Math.PI*2); const sweepArcLength=Math.PI/3;
        buf[idx]+=Math.max(0,1 - Math.abs(jd-joyR*0.25)/(ringThick*0.5))*0.22;
        buf[idx]+=Math.max(0,1 - Math.abs(jd-joyR*0.50)/(ringThick*0.5))*0.20;
        buf[idx]+=Math.max(0,1 - Math.abs(jd-joyR*0.75)/(ringThick*0.5))*0.18;
        buf[idx]+=Math.max(0,1 - Math.abs(jd-joyR*1.00)/(ringThick*0.5))*0.16;
        buf[idx]+=Math.max(0,1 - Math.abs(jd-joyR*DEADZONE)/(dzRingThick*0.5))*0.12;
        const deltaAngle=((t-jang)%(Math.PI*2)+(Math.PI*2))%(Math.PI*2);
        if(jd<joyR*0.98 && deltaAngle>0 && deltaAngle<sweepArcLength) buf[idx]+=0.9;

        if(mag>0.01){
          let joyB=0; const sd=segDist(joyCX,joyCY,px,py,x,y);
          joyB=Math.max(joyB, Math.max(0,1 - smoothStep(0, PITCH*2.4, sd))*STEM_GAIN);
          const kd=Math.hypot(x-px, y-py);
          const core=Math.exp(-Math.pow(kd/knobCoreR,2));
          const glow=Math.exp(-Math.pow(Math.max(0,kd-knobCoreR)/knobGlowR,2));
          joyB=Math.max(joyB, core*1.0 + glow*0.9);
          buf[idx]=Math.max(buf[idx], joyB);
        }

        let b=buf[idx]||0; b += (noise2(i,j)-0.5)*0.06;
        dotDraw(x,y,DOT_R, quantize(Math.max(0,b)));
      }
    }
  }

  function dotDraw(x,y,r,level){
    if(level<=0){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle=OFF; ctx.fill(); return; }
    const color = level>=1 ? RED : (level>=0.65 ? MID : DIM);
    ctx.save(); ctx.shadowColor=color; ctx.shadowBlur=8*level; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle=color; ctx.fill(); ctx.restore();
  }
  function quantize(v){ let best=0,bd=1e9; for(const s of LEVELS){ const d=Math.abs(v-s); if(d<bd){bd=d; best=s;} } return best; }
  function smoothStep(a,b,x){ const t=Math.min(1,Math.max(0,(x-a)/(b-a))); return t*t*(3-2*t); }
  function noise2(ix,iy){ return (Math.sin((ix*12.9898 + iy*78.233)*43758.5453)%1 + 1)%1; }
  function segDist(ax,ay,bx,by,px,py){ const vx=bx-ax, vy=by-ay, wx=px-ax, wy=py-ay; const c1=vx*wx+vy*wy; if(c1<=0) return Math.hypot(px-ax,py-ay); const c2=vx*vx+vy*vy; if(c2<=c1) return Math.hypot(px-bx,py-by); const t=c1/c2, sx=ax+t*vx, sy=ay+t*vy; return Math.hypot(px-sx,py-sy); }

  const observer = new ResizeObserver(entries=>{ if(entries[0]){ const {width,height}=entries[0].contentRect; updateLayout(width,height); } });
  observer.observe(document.querySelector('.pane-right'));
  requestAnimationFrame(loop);

  // --- Simple runtime checks ("tests") ---
  console.assert(typeof window.setButtonsHTML === 'function', 'setButtonsHTML API must exist');
  console.assert(document.getElementById('buttons-frame'), 'left iframe must exist');
})();
</script>
</body>
</html>
